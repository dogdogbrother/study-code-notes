# 最大矩阵

## 需求

给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。

示例:  
输入:
```js
[
  ["1","0","1","0","0"],
  ["1","0","1","1","1"],
  ["1","1","1","1","1"],
  ["1","0","0","1","0"]
]
```
输出: 6.

我们可以注意到第二批的第三个1和附近的1组成了一个3*2的长方形.

## 我的解题

对于这种题我的第一个想法是从图形规律上入手,但是想了想似乎过于复杂.

然后也就多没想,直接看了讲师的思路,他没有关注图形上的关联,而是直接把我们想要的信息转成了数据.

以示例的数组为例,[1]行数组的1的信息应该为`[[0,0],[2,4]]`,就是说有2个矩形块,第一个长度位置在0开始在0结束,第二个在2开始在4结束.

[2]行的数组都是1,得到的是`[[0,4]]`,那么我们通过这两行得到了几个矩阵呢?是2个,一个是00只有2个1的矩阵,一个是2-4的矩阵包含了6个1.

如果不理解思路真的很难处理,不过就算是理解了思路,操作起来也是麻烦的很.

最后我们把所有得到的矩阵循环下,得到最大的就是我们的答案.

```js
/**
 * @param {string[]} ops
 * @return {number}
 * 
 */
{
    [ 
        [ '1', '0', '1', '0', '0' ],
        [ '1', '0', '1', '1', '1' ],
        [ '1', '1', '1', '1', '1' ],
        [ '1', '0', '0', '1', '0' ] 
    ]
}
const test = [
    [ '1', '0', '1', '0', '0' ],
    [ '1', '0', '1', '1', '1' ],
    [ '1', '1', '1', '0', '1' ]
]
// 这个作为测试数据,我预期的值为 [ [[0,0],[2,2]], [[0,0],[2,4]] ]
/**
 * 这个作为测试数据,我预期的值为
 *  [ 
 *      [[0,0],[2,2]], 
 *      [[0,0],[2,4]],
 *      [[0,2],[4,4]]
 *  ]
 */
var maximalRectangle = function(matrix) {
    const poli = []  //  这个变量的作用是作为中间层处理的数据.
    matrix.forEach((wrapArr,wrapIndex) => {  //  先循环外层,给每一行都先给一个空数组
        poli.push([])
        wrapArr.forEach((num,index) => {  //  每一行里面只要有了1就去处理,全是0的话跳过就好了       
            if (num === '1' && (!index || !poli[wrapIndex].length)) {
                // console.log(index);
                //  这个判断有点复杂,什么意思呢,首先我们肯定是要判断是不是1的,0根据就不用管.
                //  而是如果我们1后面还有1,后面的那个1就要判断前面那个1的位置,而第一个1是不需要判断的前面的.
                //  所以这里我是单独判断下,就给初始化的1,后面的根据这个来.
                poli[wrapIndex].push([index,index]) 
                // console.log(poli[wrapIndex]);
                
            } else {
                if (num === '1' && wrapArr[index-1] === '1') {  // 之所以-1不会失败就是因为我们前面判断过,index肯定不是会是0
                    //  这个判断的意思是,如果我是1,并且我的前一任也是1的话,就更新 poli[wrapIndex] 这个数组的最后一个数组的最后一位改成index
                    poli[wrapIndex][poli[wrapIndex].length-1][1] = index
                } else if (num === '1') {
                    // 如果只是1,就代表他前面肯定是0了,那么我们就要新添加一个数组进去了
                    poli[wrapIndex].push([index,index]) 
                }
            }
        })
    });
    console.log(poli);
    // 到这里,我们打印完了我们处理过的1的位置的数据化.一共是3个大数组,里面共6个内数组.
    // 首先,保底是有6个数组,也就是6个矩阵(假设1*1也是矩阵),但是事实上我们有4个大小为3的矩阵,一个大小为1的矩阵.
    // 待续吧,头发要掉
};
maximalRectangle(test)
```
