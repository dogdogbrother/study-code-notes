(window.webpackJsonp=window.webpackJsonp||[]).push([[148],{133:function(l,n,s){"use strict";s.r(n);var e=s(0),t=Object(e.a)({},(function(){var l=this,n=l.$createElement,s=l._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":l.$parent.slotKey}},[s("h1",{attrs:{id:"使用plugin让打包更便捷"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用plugin让打包更便捷","aria-hidden":"true"}},[l._v("#")]),l._v(" 使用plugin让打包更便捷")]),l._v(" "),s("blockquote",[s("p",[l._v("前面的所有的打包后都有一个问题,当我们打包成功后是没有index.html文件的,需要我们手动添加入口文件,并引入打包好的js文件.比较麻烦,我们用plugin插件来解决这个问题.")])]),l._v(" "),s("ol",[s("li",[l._v("先安装plugin,打开官网,照着安装就行了.\n"),s("ul",[s("li",[l._v("安装 "),s("code",[l._v("npm install html-webpack-plugin -D")])]),l._v(" "),s("li",[l._v("引入 "),s("code",[l._v("const HtmlWebpackPlugin = require('html-webpack-plugin')")])]),l._v(" "),s("li",[l._v("配置使用")])])])]),l._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[l._v("{\n    entry:...,\n    output:...,\n    plugins:[new HtmlWebpackPlugin()]\n}\n    \n")])]),l._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[l._v("1")]),s("br"),s("span",{staticClass:"line-number"},[l._v("2")]),s("br"),s("span",{staticClass:"line-number"},[l._v("3")]),s("br"),s("span",{staticClass:"line-number"},[l._v("4")]),s("br"),s("span",{staticClass:"line-number"},[l._v("5")]),s("br"),s("span",{staticClass:"line-number"},[l._v("6")]),s("br")])]),s("ol",{attrs:{start:"2"}},[s("li",[l._v("打包测试,成功.但是思考个问题.我们在使用vue-cli脚手架的时候,我们全部的操作其实都是建立于dom挂载到id为app的div中.而打包自动生成的html文件,自身是没有内容的.并且我们可以在src/index.html文件中添加css,js引入等等都是不影响打包过后的效果的.由此可见,plugins是可以配置模板的.如下")])]),l._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[l._v("plugins:[new HtmlWebpackPlugin({\n    template:'src/index.html'\n})]\n")])]),l._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[l._v("1")]),s("br"),s("span",{staticClass:"line-number"},[l._v("2")]),s("br"),s("span",{staticClass:"line-number"},[l._v("3")]),s("br")])]),s("blockquote",[s("p",[l._v("我们在每次打包的成功时候,其实都是往dist目录中添加文件,并没有清空dist目录.")])]),l._v(" "),s("ol",[s("li",[s("p",[l._v("什么意思呢,就是当我们没有删除dist目录下的文件的时候,更改了output配置,这样再打包,就会发现新老版本的js文件都存在.这样虽然没问题,但毕竟不太好.我们可以使用clean-webpack-plugin改善.")])]),l._v(" "),s("li",[s("p",[l._v("安装和引入就忽略了吧,看完成后的代码.")])])]),l._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[l._v("plugins:[new HtmlWebpackPlugin({\n    template:'src/index.html'\n}),new CleanWebpackPlugin(['dist'])]\n")])]),l._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[l._v("1")]),s("br"),s("span",{staticClass:"line-number"},[l._v("2")]),s("br"),s("span",{staticClass:"line-number"},[l._v("3")]),s("br")])]),s("ol",{attrs:{start:"3"}},[s("li",[s("p",[l._v("每次打包的时候clean-webpack-plugin都会帮我们删除掉dist目录.")])]),l._v(" "),s("li",[s("p",[l._v("这里我有个以为,这两个plugin插件的执行顺序是怎么控制的呢?如果我们是先执行HtmlWebpackPlugin再执行CleanWebpackPlugin岂不是在搞笑吗.事实上我们控制不了,只能通过查看文档来获得他们动作节点,自行判断顺序.")])])]),l._v(" "),s("h2",{attrs:{id:"知识点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#知识点","aria-hidden":"true"}},[l._v("#")]),l._v(" 知识点")]),l._v(" "),s("ol",[s("li",[s("p",[l._v("plugin 可以在webpack运行到某个时刻的时候,帮你做一些事情")])]),l._v(" "),s("li",[s("p",[l._v("html-webpack-plugin会在打包结束后,自动生成一个html文件,并把打包生成的js自动引入到这个html文件中.")])]),l._v(" "),s("li",[s("p",[l._v("clean-webpack-plugin都会帮我们在每次打包动作即将开始前,删除掉指定目录.")])])])])}),[],!1,null,null,null);n.default=t.exports}}]);