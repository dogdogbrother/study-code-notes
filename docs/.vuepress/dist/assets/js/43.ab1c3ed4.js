(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{131:function(t,v,e){"use strict";e.r(v);var a=e(0),_=Object(a.a)({},(function(){var t=this,v=t.$createElement,e=t._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"异步-现在和将来"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#异步-现在和将来","aria-hidden":"true"}},[t._v("#")]),t._v(" 异步:现在和将来")]),t._v(" "),e("h2",{attrs:{id:"事件循环"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件循环","aria-hidden":"true"}},[t._v("#")]),t._v(" 事件循环")]),t._v(" "),e("p",[t._v("尽管你显然能够编写异步 JavaScript 代码，但直到最近（ES6），JavaScript 才真正内建有直接的异步概念。")]),t._v(" "),e("p",[t._v("这种说法让人感觉到惊奇,但JavaScript 引擎本身所做的只不过是在需要的时候，在给定的任意时刻执行程序中的"),e("strong",[t._v("单个代码块")]),t._v(".")]),t._v(" "),e("p",[t._v("js中对异步或是说多线程(这么说其实并不准确,异步和多线程并不是一个东西)都提供了一种机制来处理程序中多个块的执行，且执行每块时调用 JavaScript 引擎，这种机制被称为"),e("strong",[t._v("事件循环")]),t._v("。")]),t._v(" "),e("p",[t._v("打个比方说,就是js有一个永远在对一个"),e("code",[t._v("eventLoop")]),t._v("数组执行的 "),e("code",[t._v("while")]),t._v(" 循环,当我们发送一个AJAX请求时,服务器会监听返回响应,如果有响应的话就把当初写的那个回调函数插入到"),e("code",[t._v("eventLoop")]),t._v("数组尾部,当执行结束后就把这个回调函数删除掉.")]),t._v(" "),e("p",[t._v("一定要清楚，"),e("code",[t._v("setTimeout(..)")]),t._v(" 并没有把你的回调函数挂在事件循环队列中。它所做的是设定一个定时器。当定时器到时后，环境会把你的回调函数放在事件循环中，这样，在未来某个时刻的 "),e("code",[t._v("tick")]),t._v(" 会摘下并执行这个回调。")]),t._v(" "),e("p",[t._v("如果这时候事件循环中已经有 20 个项目了会怎样呢？你的回调就会等待。它得排在其他项目后面——通常没有抢占式的方式支持直接将其排到队首。这也解释了为什么\n"),e("code",[t._v("setTimeout(..)")]),t._v(" 定时器的精度可能不高。")]),t._v(" "),e("h2",{attrs:{id:"任务"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#任务","aria-hidden":"true"}},[t._v("#")]),t._v(" 任务")]),t._v(" "),e("p",[t._v("在 ES6 中，有一个新的概念建立在事件循环队列之上，叫作任务队列。这个概念给大家带来的最大影响可能是 "),e("code",[t._v("Promise")]),t._v(" 的异步特性.")]),t._v(" "),e("p",[t._v("Promise的API机制还没有公开,书中的概念也是一个理解的描述.")])])}),[],!1,null,null,null);v.default=_.exports}}]);