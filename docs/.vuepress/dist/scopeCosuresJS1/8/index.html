<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>对象 | 读书笔记</title>
    <meta name="description" content="森林看过啥都记录下">
    
    
    <link rel="preload" href="/assets/css/0.styles.b8d5990a.css" as="style"><link rel="preload" href="/assets/js/app.216c5d29.js" as="script"><link rel="preload" href="/assets/js/2.486f7cfd.js" as="script"><link rel="preload" href="/assets/js/37.d8aa4159.js" as="script"><link rel="prefetch" href="/assets/js/10.d799e58b.js"><link rel="prefetch" href="/assets/js/11.ce0ba47f.js"><link rel="prefetch" href="/assets/js/12.96ddf577.js"><link rel="prefetch" href="/assets/js/13.e7ac0ad4.js"><link rel="prefetch" href="/assets/js/14.8a7673c6.js"><link rel="prefetch" href="/assets/js/15.6c29686e.js"><link rel="prefetch" href="/assets/js/16.e76c5f69.js"><link rel="prefetch" href="/assets/js/17.1fcaedf8.js"><link rel="prefetch" href="/assets/js/18.0f8dd9ea.js"><link rel="prefetch" href="/assets/js/19.be345b8e.js"><link rel="prefetch" href="/assets/js/20.8bc82249.js"><link rel="prefetch" href="/assets/js/21.22728326.js"><link rel="prefetch" href="/assets/js/22.5b3c5219.js"><link rel="prefetch" href="/assets/js/23.b8e6015c.js"><link rel="prefetch" href="/assets/js/24.e89b43ac.js"><link rel="prefetch" href="/assets/js/25.3b059345.js"><link rel="prefetch" href="/assets/js/26.2741699f.js"><link rel="prefetch" href="/assets/js/27.fb553b29.js"><link rel="prefetch" href="/assets/js/28.eea39b01.js"><link rel="prefetch" href="/assets/js/29.0faebd23.js"><link rel="prefetch" href="/assets/js/3.7bc6a70f.js"><link rel="prefetch" href="/assets/js/30.c9eaf1d1.js"><link rel="prefetch" href="/assets/js/31.06fa85ea.js"><link rel="prefetch" href="/assets/js/32.20910127.js"><link rel="prefetch" href="/assets/js/33.f3325072.js"><link rel="prefetch" href="/assets/js/34.fde37b7b.js"><link rel="prefetch" href="/assets/js/35.8755d537.js"><link rel="prefetch" href="/assets/js/36.0f0d01af.js"><link rel="prefetch" href="/assets/js/38.8c08cddb.js"><link rel="prefetch" href="/assets/js/39.9458e5c6.js"><link rel="prefetch" href="/assets/js/4.51f9489f.js"><link rel="prefetch" href="/assets/js/40.b594518e.js"><link rel="prefetch" href="/assets/js/41.86f76856.js"><link rel="prefetch" href="/assets/js/42.b07801d2.js"><link rel="prefetch" href="/assets/js/43.00535034.js"><link rel="prefetch" href="/assets/js/5.5a559a97.js"><link rel="prefetch" href="/assets/js/6.3a0afaed.js"><link rel="prefetch" href="/assets/js/7.fd4a74d6.js"><link rel="prefetch" href="/assets/js/8.f3f067dc.js"><link rel="prefetch" href="/assets/js/9.a03fe451.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b8d5990a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">读书笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/JavaScriptDesignPatterns/" class="nav-link">《JavaScript设计模式与开发实践》</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="《你不知道的JS》" class="dropdown-title"><span class="title">《你不知道的JS》</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/scopeCosuresJS1/" class="nav-link router-link-active">上册</a></li><li class="dropdown-item"><!----> <a href="/scopeCosuresJS2/" class="nav-link">中册</a></li></ul></div></div><div class="nav-item"><a href="/buildStation/" class="nav-link">建站小攻略</a></div><div class="nav-item"><a href="/nextjs/" class="nav-link">服务端渲染nextJS</a></div><div class="nav-item"><a href="https://github.com/dogdogbrother/study-code-notes" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/JavaScriptDesignPatterns/" class="nav-link">《JavaScript设计模式与开发实践》</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="《你不知道的JS》" class="dropdown-title"><span class="title">《你不知道的JS》</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/scopeCosuresJS1/" class="nav-link router-link-active">上册</a></li><li class="dropdown-item"><!----> <a href="/scopeCosuresJS2/" class="nav-link">中册</a></li></ul></div></div><div class="nav-item"><a href="/buildStation/" class="nav-link">建站小攻略</a></div><div class="nav-item"><a href="/nextjs/" class="nav-link">服务端渲染nextJS</a></div><div class="nav-item"><a href="https://github.com/dogdogbrother/study-code-notes" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/scopeCosuresJS1/1/" class="sidebar-link">第1章.作用域是什么</a></li><li><a href="/scopeCosuresJS1/2/" class="sidebar-link">第2章.词法作用域</a></li><li><a href="/scopeCosuresJS1/3/" class="sidebar-link">第3章.函数作用域和块作用域</a></li><li><a href="/scopeCosuresJS1/4/" class="sidebar-link">第4章.提升</a></li><li><a href="/scopeCosuresJS1/5/" class="sidebar-link">第5章.作用域是闭包</a></li><li><a href="/scopeCosuresJS1/6/" class="sidebar-link">第6章.关于this的2个误解</a></li><li><a href="/scopeCosuresJS1/7/" class="sidebar-link">第7章.this全面解析</a></li><li><a href="/scopeCosuresJS1/8/" class="active sidebar-link">第8章.对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/scopeCosuresJS1/8/#语法" class="sidebar-link">语法</a></li><li class="sidebar-sub-header"><a href="/scopeCosuresJS1/8/#类型" class="sidebar-link">类型</a></li><li class="sidebar-sub-header"><a href="/scopeCosuresJS1/8/#内置对象" class="sidebar-link">内置对象</a></li><li class="sidebar-sub-header"><a href="/scopeCosuresJS1/8/#内容" class="sidebar-link">内容</a></li><li class="sidebar-sub-header"><a href="/scopeCosuresJS1/8/#小结" class="sidebar-link">小结</a></li></ul></li><li><a href="/scopeCosuresJS1/9/" class="sidebar-link">第9章.混合对象&quot;类&quot;</a></li><li><a href="/scopeCosuresJS1/10/" class="sidebar-link">第10章.原型</a></li><li><a href="/scopeCosuresJS1/11/" class="sidebar-link">第10章.行为委托</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="对象"><a href="#对象" aria-hidden="true" class="header-anchor">#</a> 对象</h1> <blockquote><p><strong>前端界有句耳熟能详的话,万物皆对象</strong><br>
this章节里面我们介绍了函数调用位置的不同会造成this绑定对象的不同。但是对象到底是什么,为什么我们需要绑定它们呢？</p></blockquote> <h2 id="语法"><a href="#语法" aria-hidden="true" class="header-anchor">#</a> 语法</h2> <p>对象可以通过两种形式定义：声明（文字）形式和构造形式。</p> <p>对象的文字语法大概是这样：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> myObj <span class="token operator">=</span> <span class="token punctuation">{</span> 
    key<span class="token punctuation">:</span> value <span class="token comment">// ... </span>
<span class="token punctuation">}</span><span class="token punctuation">;</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>构造形式大概是这样：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> myObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
myObj<span class="token punctuation">.</span>key <span class="token operator">=</span> value<span class="token punctuation">;</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>构造形式和文字形式生成的对象是一样的。唯一的区别是，在文字声明中你可以添加多个 键 / 值对，但是在构造形式中你必须逐个添加属性。</p> <p><strong>用上面的“构造形式”来创建对象是非常少见的，一般来说你会使用文字语 法，绝大多数内置对象也是这样做的</strong></p> <h2 id="类型"><a href="#类型" aria-hidden="true" class="header-anchor">#</a> 类型</h2> <p>对象是 JavaScript 的基础。在 JavaScript 中一共有六种主要类型（术语是“语言类型”）：</p> <ul><li>string</li> <li>number</li> <li>boolean</li> <li>null</li> <li>undefined</li> <li>object</li></ul> <p>注意，简单基本类型（string、boolean、number、null 和 undefined）本身并不是对象。</p> <p>null 有时会被当作一种对象类型，但是这其实只是语言本身的一个 bug，即对 null 执行 typeof null 时会返回字符串 &quot;object&quot;。实际上，null 本身是基本类型。</p> <blockquote><p>原理是这样的，不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判 断为 object 类型，null 的二进制表示是全 0，自然前三位也是 0，所以执行 typeof 时会返回“object”。</p></blockquote> <h2 id="内置对象"><a href="#内置对象" aria-hidden="true" class="header-anchor">#</a> 内置对象</h2> <p>JavaScript 中还有一些对象子类型，通常被称为内置对象。有些内置对象的名字看起来和 简单基础类型一样，不过实际上它们的关系更复杂，我们稍后会详细介绍。</p> <ul><li>string</li> <li>number</li> <li>boolean</li> <li>object</li> <li>Function</li> <li>Array</li> <li>Date</li> <li>RegExp</li> <li>Error</li></ul> <p>这些内置对象从表现形式来说很像其他语言中的类型（type）或者类（class），比如 Java 中的 String 类。</p> <p>但是在 JavaScript 中，它们实际上只是一些内置函数。这些内置函数可以当作构造函数来使用，从而可以构造一个对应子类型的新对象。</p> <p>代码举例说明一下:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> strPrimitive <span class="token operator">=</span> <span class="token string">&quot;I am a string&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">typeof</span> strPrimitive<span class="token punctuation">;</span> <span class="token comment">// &quot;string&quot; </span>
strPrimitive <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">;</span> <span class="token comment">// false</span>

<span class="token keyword">var</span> strObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span> <span class="token string">&quot;I am a string&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">typeof</span> strObject<span class="token punctuation">;</span> <span class="token comment">// &quot;object&quot; </span>
strObject <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

<span class="token comment">// 检查 sub-type 对象 </span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> strObject <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [object String]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><strong>代码分析:</strong> 这代码什么意思呢,上面的例子是单纯的字面量,它只是个基础类型,而中间用<code>new String</code>构造出来的虽然也是<code>string</code>,但同时也是对象.<br>
问题来了,既然上面的不是<code>object</code>.那么就不应该会有<code>.length</code>等方法.事实上,在必要时语言会自动把字符串字面量转换成一个 String 对象，也就是说你并不需要 显式创建一个对象(也就是说,其实你在创建字符串的时候应该用new形式)。</p> <blockquote><p>前同样的事情发生在数字和布尔值上,<code>null</code>和<code>undefined</code>没有对应的构造形式，它们只有文字形式。相反,<code>Date</code>只有构造，没有文字形式。</p></blockquote> <h2 id="内容"><a href="#内容" aria-hidden="true" class="header-anchor">#</a> 内容</h2> <p>对象的内容是由一些存储在特定命名位置的（任意类型的）值组成的， 我们称之为属性。</p> <p>需要强调的一点是，当我们说“内容”时，似乎在暗示这些值实际上被存储在对象内部， 但是这只是它的表现形式。在引擎内部，这些值的存储方式是多种多样的，一般并不会存在对象容器内部。存储在对象容器内部的是这些属性的名称，它们就像指针（从技术角度来说就是引用）一样，指向这些值真正的存储位置。</p> <p>思考下面的代码：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> myObject <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
myObject<span class="token punctuation">.</span>a<span class="token punctuation">;</span> <span class="token comment">// 2 </span>
myObject<span class="token punctuation">[</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><code>.a</code>语法通常被称为“属性访问”，<code>[&quot;a&quot;]</code>语法通常被称为“键访问”。</p> <p>在对象中，属性名永远都是字符串。如果你使用 string（字面量）以外的其他值作为属性 名，那它首先会被转换为一个字符串。即使是数字或是对象也不例外.举个代码例子:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> myObject <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
myObject<span class="token punctuation">[</span><span class="token boolean">true</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">;</span>
myObject<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;bar&quot;</span><span class="token punctuation">;</span> 
myObject<span class="token punctuation">[</span>myObject<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;baz&quot;</span><span class="token punctuation">;</span> 

myObject<span class="token punctuation">[</span><span class="token string">&quot;true&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// &quot;foo&quot; </span>
myObject<span class="token punctuation">[</span><span class="token string">&quot;3&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// &quot;bar&quot; </span>
myObject<span class="token punctuation">[</span><span class="token string">&quot;[object Object]&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// &quot;baz&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="_1-可计算属性名"><a href="#_1-可计算属性名" aria-hidden="true" class="header-anchor">#</a> 1. 可计算属性名</h3> <p>ES6 增加了可计算属性名（与Symbol相关），可以在文字形式中使用 [] 包裹一个表达式来当作属性名：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> prefix <span class="token operator">=</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> myObject <span class="token operator">=</span> <span class="token punctuation">{</span> 
    <span class="token punctuation">[</span>prefix <span class="token operator">+</span> <span class="token string">&quot;bar&quot;</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">,</span> 
    <span class="token punctuation">[</span>prefix <span class="token operator">+</span> <span class="token string">&quot;baz&quot;</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">&quot;world&quot;</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>

myObject<span class="token punctuation">[</span><span class="token string">&quot;foobar&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// hello </span>
myObject<span class="token punctuation">[</span><span class="token string">&quot;foobaz&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// world</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="_2-数组"><a href="#_2-数组" aria-hidden="true" class="header-anchor">#</a> 2. 数组</h3> <p>数组也支持 [] 访问形式，不过就像我们之前提到过的，数组有一套更加结构化的值存储机制.</p> <p>数组也是对象，所以虽然每个下标都是整数，你仍然可以给数组添加属性：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> myArray <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token string">&quot;bar&quot;</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>
myArray<span class="token punctuation">.</span>baz <span class="token operator">=</span> <span class="token string">&quot;baz&quot;</span><span class="token punctuation">;</span>
myArray<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">// 3</span>
myArray<span class="token punctuation">.</span>baz<span class="token punctuation">;</span> <span class="token comment">// &quot;baz&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>可以看到虽然添加了命名属性（无论是通过 . 语法还是 [] 语法），数组的 length 值并未发 生变化。</p> <blockquote><p>注意：如果你试图向数组添加一个属性，但是属性名“看起来”像一个数字，那它会变成 一个数值下标,并且数组的长度也会改变.</p></blockquote> <h3 id="_3-复制对象"><a href="#_3-复制对象" aria-hidden="true" class="header-anchor">#</a> 3. 复制对象</h3> <blockquote><p><strong>如何复制一个对象?</strong><br>
看起来应该有一个内置的<code>copy()</code>方法,实际上事情比你想象的更复杂，因为我们无法选择一个默认的复制算法。</p></blockquote> <p>举例说明,我们思考一下这个对象:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">anotherFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/*..*/</span> <span class="token punctuation">}</span>
<span class="token keyword">var</span> anotherObject <span class="token operator">=</span> <span class="token punctuation">{</span> 
    c<span class="token punctuation">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> anotherArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> myObject <span class="token operator">=</span> <span class="token punctuation">{</span> 
    a<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    b<span class="token punctuation">:</span> anotherObject<span class="token punctuation">,</span> <span class="token comment">// 引用一个对象，不是复本！ </span>
    c<span class="token punctuation">:</span> anotherArray<span class="token punctuation">,</span> <span class="token comment">// 另一个引用,是数组！ </span>
    d<span class="token punctuation">:</span> anotherFunction 
<span class="token punctuation">}</span><span class="token punctuation">;</span>

anotherArray<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span> anotherObject<span class="token punctuation">,</span> myObject <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>如何准确地表示 myObject 的复制呢？</p> <blockquote><p><strong>忍不住要吐槽一句</strong><br>
深拷贝是啥浅拷贝又是啥,面试的时候经常问,但是我个人真的很难理解</p></blockquote> <p>对于浅拷贝来说，复制出的新对象中 a 的值会复制旧对象中 a 的值，也就是 2，但是新对象中 b、c、d 三个属性其实只是三个引用，它们和旧对象中 b、c、d 引用的对象是一样的。</p> <p>对于深复制来说，除了复制 myObject 以外还会复 制 anotherObject 和 anotherArray。这时问题就来了，anotherArray 引用了 anotherObject 和 myObject，所以又需要复制 myObject，这样就会由于循环引用导致死循环。(应该怎么办呢,手写递归?JSON序列化?)</p> <p>浅复制非常易懂并且问题要少得多，所以 ES6 定义了<code>Object.assign(..)</code>方法来实现浅复制。</p> <h3 id="_4-属性描述符"><a href="#_4-属性描述符" aria-hidden="true" class="header-anchor">#</a> 4. 属性描述符</h3> <p>在<strong>ES5</strong>之前，JavaScript 语言本身并没有提供可以直接检测属性特性的方法，比如判断属性是否是只读。</p> <p>但是从<strong>ES5</strong>开始，所有的属性都具备了属性描述符。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> myObject <span class="token operator">=</span> <span class="token punctuation">{</span> 
    a<span class="token punctuation">:</span><span class="token number">2</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span> myObject<span class="token punctuation">,</span> <span class="token string">&quot;a&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// { </span>
<span class="token comment">// value: 2,</span>
<span class="token comment">// writable: true,</span>
<span class="token comment">// enumerable: true,</span>
<span class="token comment">// configurable: true</span>
<span class="token comment">// }</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>这个对象的值不仅仅只是一个2,它还包含另外三个特性：writable（可写）、 enumerable（可枚举）和 configurable（可配置）。</p> <h3 id="_5-get"><a href="#_5-get" aria-hidden="true" class="header-anchor">#</a> 5. [[Get]]</h3> <p>我们先看一个非常普通的代码:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> myObject <span class="token operator">=</span> <span class="token punctuation">{</span> 
    a<span class="token punctuation">:</span> <span class="token number">2</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>
myObject<span class="token punctuation">.</span>a<span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote><p><code>myObject.a</code>是一次属性访问，但是这条语句并不仅仅是在<code>myObjet</code>中查找名字为<code>a</code>的属性，虽然看起来好像是这样。</p></blockquote> <p>事实上却不是这样的,在语言规范中，<code>myObject.a</code>在<code>myObject</code>上实际上是实现了 [[Get]] 操作（有点像函数调 用：<a href="">[Get]</a>）。对象默认的内置 [[Get]] 操作首先在对象中查找是否有名称相同的属性，如果找到就会返回这个属性的值。然而，如果没有找到名称相同的属性，按照 [[Get]] 算法的定义会执行另外一种非常重要的行为。我们会在后面的章节里介绍这个行为（其实就是遍历可能存在的 [[Prototype]] 链，也就是原型链）。</p> <p>如果无论如何都没有找到名称相同的属性，那 [[Get]] 操作会返回值 undefined.</p> <h3 id="_6-put"><a href="#_6-put" aria-hidden="true" class="header-anchor">#</a> 6. [[Put]]</h3> <blockquote><p><strong>既然有可以获取属性值的 [[Get]] 操作，就一定有对应的 [[Put]] 操作。</strong><br>
常规来讲,我们会认为给对象的属性赋值会触发 [[Put]] 来设置或者创建这个属性。但是实际情况并不全是这样.</p></blockquote> <p>[[Put]] 被触发时，实际的行为取决于许多因素，包括对象中是否已经存在这个属性（这是最重要的因素）。</p> <p>如果已经存在这个属性，[[Put]] 算法大致会检查下面这些内容。</p> <ol><li>属性是否是访问描述符,如果是并且存在 <code>setter</code> 就调用 <code>setter</code>。</li> <li>属性的数据描述符中 <code>writable</code> 是否是 <code>false</code> ？如果是，在非严格模式下静默失败，在 严格模式下抛出 <code>TypeError</code> 异常。</li> <li>如果都不是，将该值设置为属性的值。</li></ol> <p>如果对象中不存在这个属性，[[Put]] 操作会更加复杂,后面原型链那里会讲到.</p> <h3 id="_7-getter和setter"><a href="#_7-getter和setter" aria-hidden="true" class="header-anchor">#</a> 7. Getter和Setter</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> myObject <span class="token operator">=</span> <span class="token punctuation">{</span> 
    <span class="token comment">// 给 a 定义一个 getter </span>
    <span class="token keyword">get</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>
    myObject<span class="token punctuation">,</span> <span class="token comment">// 目标对象 </span>
    <span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 属性名</span>
    <span class="token punctuation">{</span> <span class="token comment">// 描述符</span>
        <span class="token function-variable function">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">*</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 给 b 设置一个 getter</span>
        enumerable<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token comment">// 确保 b 会出现在对象的属性列表中,可枚举</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">)</span>
myObject<span class="token punctuation">.</span>a<span class="token punctuation">;</span> <span class="token comment">// 2 </span>
myObject<span class="token punctuation">.</span>b<span class="token punctuation">;</span> <span class="token comment">// 4</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><blockquote><p>用过 <strong>VUE</strong> 的人对<code>defineProperty</code>这个词很熟悉,这就是 <strong>VUE</strong> 双向绑定的实现原理.</p></blockquote> <p><strong>代码分析:</strong> 不管是<code>a</code>属性还是<code>b</code>属性,都是隐性创建的.<code>get</code>方法覆盖了对象自身的[[Get]]操作.</p> <p>再看一段代码:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> myObject <span class="token operator">=</span> <span class="token punctuation">{</span> 
    <span class="token comment">// 给 a 定义一个 getter</span>
    <span class="token keyword">get</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>

myObject<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> 
myObject<span class="token punctuation">.</span>a<span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>代码分析:</strong> 通常来说 <code>getter</code> 和 <code>setter</code> 是成对出现的,现在没有设置<code>set</code>导致我们给<code>a</code>赋值的时候<code>set</code>操作会忽略赋值操作(所以不会报错).不过即使有合法的<code>setter</code>,由于我们自定义的<code>getter</code>只会返回2,所以也只会拿到2.</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> myObject <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token comment">// 给 a 定义一个 getter </span>
    <span class="token keyword">get</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_a_<span class="token punctuation">;</span> 
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 给 a 定义一个 setter </span>
    <span class="token keyword">set</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>_a_ <span class="token operator">=</span> val <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>

myObject<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
myObject<span class="token punctuation">.</span>a<span class="token punctuation">;</span> <span class="token comment">// 4</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><blockquote><p>属性名 <code>_a_</code> 只是一种惯例，没有任何特殊的行为.</p></blockquote> <h3 id="_8-存在性"><a href="#_8-存在性" aria-hidden="true" class="header-anchor">#</a> 8. 存在性</h3> <p><code>myObject.a</code>的属性访问返回值可能是<code>undefined</code>，但是这个值有可能是属性中存储的<code>undefined</code>，也可能是因为属性不存在所以返回<code>undefined</code>。那么如何区分 这两种情况呢？</p> <p>用两种方法的代码举例:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> myObject <span class="token operator">=</span> <span class="token punctuation">{</span> 
    a<span class="token punctuation">:</span><span class="token number">2</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span> <span class="token keyword">in</span> myObject<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true </span>
<span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span> <span class="token keyword">in</span> myObject<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>

myObject<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span> <span class="token string">&quot;a&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true </span>
myObject<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span> <span class="token string">&quot;b&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><code>in</code>操作符会检查属性是否在对象及其 [[Prototype]] 原型链中。相比之下，<code>hasOwnProperty(..)</code>只会检查属性是否在<code>myObject</code>对象中，不会检查 [[Prototype]] 链。</p> <blockquote><p>也有例外,通过<code>Object.create(null)</code>来创建的对象没有<code>Object.prototype</code>,所以会找不到<code>hasOwnProperty(..)</code>方法,我们可以使用<code>Object.prototype.hasOwnProperty.call(myObject,&quot;a&quot;)</code>强行判断.</p></blockquote> <h4 id="_1-枚举"><a href="#_1-枚举" aria-hidden="true" class="header-anchor">#</a> 1. 枚举</h4> <p><code>for..in</code>循环其实就是枚举,但是需要注意的是,不应该在数组中使用<code>for..in</code>,因为这种枚举不仅会包含所有数值索引，还会包含所有可枚举属性。</p> <p>如何区分属性是否可枚举：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>myObject<span class="token punctuation">.</span><span class="token function">propertyIsEnumerable</span><span class="token punctuation">(</span> <span class="token string">&quot;b&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><code>propertyIsEnumerable(..)</code>会检查给定的属性名是否直接存在于对象中（而不是在原型链 上）并且满足<code>enumerable:true</code>。</p> <p><code>Object.keys(..)</code>会返回一个数组，包含所有可枚举属性.</p> <p><code>Object.getOwnPropertyNames(..)</code>会返回一个数组，包含所有属性，无论它们是否可枚举。</p> <h4 id="_2-遍历"><a href="#_2-遍历" aria-hidden="true" class="header-anchor">#</a> 2. 遍历</h4> <p>遍历的方法有很多,上面说了<code>for in</code>,还有我们平时常用的<code>for</code>循环,<code>forEach</code>辅助迭代器等等.</p> <p>但是这些遍历的方法这实际上并不是在遍历值，而是遍历下标来指向值.</p> <blockquote><p><strong>如何直接遍历值而不是数组下标（或者对象属性）呢？</strong><br> <code>ES6</code>增加了一种用来遍历数组的<code>for..of</code>循环语法（如果对象本身定义了迭代器的话也可以遍历对象）</p></blockquote> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> myArray <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> v <span class="token keyword">of</span> myArray<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> v <span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
<span class="token comment">// 1 </span>
<span class="token comment">// 2 </span>
<span class="token comment">// 3</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><code>for..of</code>循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的<code>next()</code>方法来遍历所有返回值。</p> <p>数组有内置的 @@iterator，因此 <code>for..of</code> 可以直接应用在数组上。我们使用内置的 @@ iterator 来手动遍历数组，看看它是怎么工作的：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> myArray <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> it <span class="token operator">=</span> myArray<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { value:1, done:false } </span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { value:2, done:false } </span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { value:3, done:false } </span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { done:true }</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><blockquote><p><strong>Symbol</strong><br>
我们使用 ES6 中的符号<code>Symbol.iterator</code>来获取对象的 @@iterator 内部属性</p></blockquote> <p>调用迭代器的 <code>next()</code> 方法会返回形式为 <code>{ value: .. , done: .. }</code> 的值， <code>value</code> 是当前的遍历值，<code>done</code> 是一个布尔值，表示是否还有可以遍历的值。</p> <p>和数组不同，普通的对象没有内置的 @@iterator，所以无法自动完成<code>for..of</code>遍历。之所以要这样做，有许多非常复杂的原因(简单来说就是js中对象以后可能变得不同,为了避免冲突).</p> <p>当然，你可以给任何想遍历的对象定义 @@iterator，代码举例：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//本来我是想写代码的,但是感觉又有点复杂,虽然for..of配合自定义迭代器很灵活很强大,但是真的需要的时候我再翻书看这里把.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="小结"><a href="#小结" aria-hidden="true" class="header-anchor">#</a> 小结</h2> <ol><li><p>JavaScript 中的对象有字面形式（比如 <code>var a = { .. }</code>）和构造形式（比如 <code>var a = new Array(..)</code>）。字面形式更常用，不过有时候构造形式可以提供更多选项。</p></li> <li><p>许多人都以为“JavaScript 中万物都是对象”，这是错误的。对象是 6 个（或者是 7 个，取决于你的观点）基础类型之一。对象有包括<code>function</code>在内的子类型，不同子类型具有不同的行为，比如内部标签 [object Array] 表示这是对象的子类型数组。</p></li> <li><p>对象就是键 / 值对的集合。可以通过<code>.propName</code>或者 [&quot;propName&quot;] 语法来获取属性值。访问属性时，引擎实际上会调用内部的默认 [[Get]] 操作（在设置属性值时是 [[Put]]）， [[Get]] 操作会检查对象本身是否包含这个属性，如果没找到的话还会查找 [[Prototype]] 链</p></li> <li><p>属性的特性可以通过属性描述符来控制，比如<code>writable</code>和<code>configurable</code>。此外，可以使用 <code>Object.preventExtensions(..)</code>、<code>Object.seal(..)</code> 和 <code>Object.freeze(..)</code> 来设置对象（及其 属性）的不可变性级别。(不变性的内容我没有写,被我忽略了,我感觉没啥大用)</p></li> <li><p>属性不一定包含值——它们可能是具备 getter/setter 的“访问描述符”。此外，属性可以是可枚举或者不可枚举的，这决定了它们是否会出现在<code>for..in</code>循环中。</p></li> <li><p>你可以使用 ES6 的 <code>for..of</code> 语法来遍历数据结构（数组、对象，等等）中的值，<code>for..of</code> 会寻找内置或者自定义的 @@iterator 对象并调用它的 <code>next()</code> 方法来遍历数据值。</p></li></ol></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/scopeCosuresJS1/7/" class="prev">第7章.this全面解析</a></span> <span class="next"><a href="/scopeCosuresJS1/9/">第9章.混合对象&quot;类&quot;</a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.216c5d29.js" defer></script><script src="/assets/js/2.486f7cfd.js" defer></script><script src="/assets/js/37.d8aa4159.js" defer></script>
  </body>
</html>
