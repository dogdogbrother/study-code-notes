# this全面解析

>**这本书的精髓,有点长,包含了调用位置/绑定规则/优先级/绑定例外/this词法**  
上一章我们说到,this是在调用时绑定的,完全取决于函数的调用位置(也就是函数的调用方法).

## 调用位置

**在理解`this`的绑定过程之前,首先要理解调用位置:只有仔细分析调用位置才能回答这个问题：这个`this`到底引用的是什么?**

通常来说，寻找调用位置就是寻找“函数被调用的位置”，但是做起来并没有这么简单， 因为某些编程模式可能会隐藏真正的调用位置。

所以重要的是要**分析调用栈**.

下面用代码来看看到底什么是调用栈和调用位置.

```js
function baz() { 
    // 当前调用栈是：baz 
    // 因此，当前调用位置是全局作用域 
    console.log( "baz" ); 
    bar(); // <-- bar 的调用位置 
}

function bar() {
    // 当前调用栈是 baz -> bar 
    // 因此，当前调用位置在 baz 中 
    console.log( "bar" ); 
    foo(); // <-- foo 的调用位置 
}

function foo() { 
    // 当前调用栈是 baz -> bar -> foo 
    // 因此，当前调用位置在 bar 中 
    console.log( "foo" ); 
}

baz(); // <-- baz 的调用位置
```
**我们可以把调用栈想象成一个函数调用链**



## 绑定规则

>**我们来看看在函数的执行过程中调用位置如何决定 this 的绑定对象。**  
你必须找到调用位置，然后判断需要应用下面四条规则中的哪一条。我们首先会分别解释 这四条规则，然后解释多条规则都可用时它们的优先级如何排列。

1. 默认绑定
首先要介绍的是最常用的函数调用类型：独立函数调用。可以把这条规则看作是无法应用 其他规则时的默认规则。

思考一下下面的代码：

```js
function foo() { 
    console.log( this.a ); 
}

var a = 2; 

foo(); // 2
```

首先,我们知道的是`a`是全局变量,但是为什么`this.a`被解析成了全局变量中的a呢?

是因为在本例中,函数调用时应用了`this`的默认绑定,因此`this`指向全局变量.

那么我们怎么知道这里应用了**默认绑定**呢?

可以通过分析调用位置来看看`foo()`是如何调用的,在代码中,`foo()`是直接使用不带任何修饰的函数引用进行调用的，因此只能使用**默认绑定**,无法应用其他规则。

如果使用严格模式（strict mode）,那么全局对象将无法使用默认绑定，因此`this`会绑定到`undefined`.

2. 隐式绑定

这条需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包 含，不过这种说法可能会造成一些误导。

思考下面的代码：
```js
function foo() { 
    console.log( this.a ); 
}

var obj = { 
    a: 2, 
    foo: foo 
};

obj.foo(); // 2
```
`foo()`函数是何被当作引用属性添加到`obj`中的,无论是直接在`obj`中定义还是先定义再添加为引用属性，这个函数严格来说都不属于`obj`对象。

然而，调用位置会使用`obj`上下文来引用函数，因此你可以说函数被调用时`obj`对象 **"拥有"** 或者 **"包含"**它。

无论你如何称呼这个模式，当`foo()`被调用时，它的落脚点确实指向`obj`对象。当函数引用有上下文对象时，隐式绑定规则会把函数调用中的`this`绑定到这个上下文对象。因为调用`foo()`时`this`被绑定到`obj`，因此`this.a`和`obj.a`是一样的。

### 隐式丢失
一个最常见的`this`绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把`this`绑定到全局对象或者`undefined`上，取决于是否是严格模式。

例子代码如下:
```js
function foo() {
    console.log( this.a );
}

var obj = { 
    a: 2, 
    foo: foo 
};

var bar = obj.foo; // 函数别名！

var a = "oops, global"; // a 是全局对象的属性

bar(); // "oops, global"
```
虽然`bar`是`obj.foo`的一个引用，但是实际上，它引用的是`foo`函数本身，因此此时的`bar()`其实是一个不带任何修饰的函数调用，因此应用了默认绑定。

一种更微妙、更常见并且更出乎意料的情况发生在传入回调函数时：
```js
function foo() { 
    console.log( this.a ); 
}

function doFoo(fn) {
    function doFoo(fn) {
    fn(); // <-- 调用位置！
}

var obj = { 
    a: 2, 
    foo: foo 
};

var a = "oops, global"; // a 是全局对象的属性

doFoo( obj.foo ); // "oops, global"
```


















