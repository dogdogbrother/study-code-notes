# 作用域是什么
 

>**一脸懵逼**  
这章的内容有点抽象，也整理不出多少东西来

## 编译原理

在传统的编译语言的流程中，程序的一段源代码在执行之前会经历三个步骤，统称为“编译”。

**1. 分词/词法分析**  
将字符串分解成有意义的代码块,例如`var = 2;`,会被分解成`var`、`a`、`=`、`2`、`;`

**2. 解析/语法分析**  
把词法单元流数组([var,a,=,2,;]),转换成一个由元素逐级嵌套组成的树，也就是**抽象语法树(AST)**

**3. 代码生成**  
将AST转换为可执行代码的过程,简单来说就是有某种方法可以将``var a = 2;`的AST转化为一组机器指令,用来创建一个叫做a的变量(包括分配内存等),并将一个值存储在a中.

对于js来说,大部分情况下编译发生在代码执行前的几微妙的时间内.简单来说,任何js代码片段在执行前都会进行编译.


## 理解作用域

利用 **引擎**,**编译器**,**作用域**,来完成`var a = 2;`的处理

1. 当看到`var a = 2;`时,我们认为这是一个生命,但是编译器却认为这里有两个完全不同的声明,一个由编译器在编译时处理,另一个则由引擎在运行时处理

2. 遇到`var a`,编译器会询问作用域是否已经有一个该名称的变量存在同一个作用域的集合中,如果是,则忽略该生命继续编译.否则他就会要求作用域在当前集合中声明一个新的变量,并命名为a.

3. 接下来编译器会为引擎生成运行时所需要的代码,这些代码用来处理`a=2`这个赋值操作.引擎运行时会首先询问作用域,当前集合中是否存在a变量,是的话就赋值给他,不是的话继续查找该变量.如果一直找不到,就抛异常.

### 为了进一步理解,我们需要多介绍一点编译器的术语(这章最恶心的地方来了)

编译器在编译的第二步中生成了代码,引擎执行它时,会通过查找a来判断它是否已被声明过.但是引擎执行怎样的查找,会影响最终的查找结果.  
在上面的例子中,引擎会为变量a进行LHS查询.(另外一种查找的类型叫做RHS).  
换句话说,当变量出现在赋值操作的左侧时进行LHS查询,出现在右侧时进行RHS查询.
讲的更准确一点,RHS查询与简单的查找某个变量的值别无二致而LHS查询是试图找到变量的容器本身.  
**可以理解RHS为"得到某某值"的行为**

参考下面的程序,其中既有LHS也有RHS引用

```js
function foo(a) {
    console.log(a)
}
foo(2);
```

`foo(2)`的调用需要对`foo`进行RHS引用.代码中还有一个隐形的`a=2`的操作,这里要用LHS来找到a.还要还要RHS找到2,并把值给`console.log()`,`console.log`本身需要引用,我们要对console对象进行RHS查询,检查得到的值里面有没有一个叫做`log`的方法.
 
 ## 小测试

 1. 找到三处LHS查询.
 2. 找到四处RHS查询

 ```js
function foo(a){
    var b = a;
    return a + b;
}
var c = foo(2)
 ```

`var c = ...`(LHS),`... = foo()`(RHS),`(a = 2)`(LFS),`b = ... `(LFS),`.. = a`(RHS),`a+b`(2个RHS)

## 嵌套作用域

这个其实没什么好说,作为一个前端谁还不知道作用域是咋回事啊.

## 异常
>**为什么区分LHS和RHS是一件重要的事呢?**  
因为在变量还没有还没有声明的情况下,这两种的查询行为是不一样的.

当我们对一个不存在的变量进行RHS查询时,RHS查询了所有嵌套的作用域都找不到,引擎就会抛出`ReferenceError`异常.(Reference是引用的意思)

相较之下,当引擎执行LHS查询时,如果也没找到目标变量,全局作用域中就会创建一个具有该名称的变量,并将其返还给引擎,前提是程序运行在非"严格模式"下.

ES5中引入了"严格模式",与正常模式有许多不同.其中一个不同的行为是禁止自动或隐式的创建全局变量.因此在严格模式中LHS查询失败时,并不会创建并返回一个全局变量,引擎同样的会抛出一个`ReferenceError`异常.

接下来,如果RHS查询找到了个变量,但是你对这个变量的值进行不合理的操作,例如对一个非函数的值进行了函数调用,就会抛出`TypeError`异常.







