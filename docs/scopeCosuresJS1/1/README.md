# 作用域是什么
 

>**一脸懵逼**  
这章的内容有点抽象，也整理不出多少东西来

## 编译原理

在传统的编译语言的流程中，程序的一段源代码在执行之前会经历三个步骤，统称为“编译”。

**1. 分词/词法分析**  
将字符串分解成有意义的代码块,例如`var = 2;`,会被分解成`var`、`a`、`=`、`2`、`;`

**2. 解析/语法分析**  
把词法单元流数组([var,a,=,2,;]),转换成一个由元素逐级嵌套组成的树，也就是**抽象语法树(AST)**

**3. 代码生成**  
将AST转换为可执行代码的过程,简单来说就是有某种方法可以将``var a = 2;`的AST转化为一组机器指令,用来创建一个叫做a的变量(包括分配内存等),并将一个值存储在a中.

对于js来说,大部分情况下编译发生在代码执行前的几微妙的时间内.简单来说,任何js代码片段在执行前都会进行编译.


## 理解作用域

利用 **引擎**,**编译器**,**作用域**,来完成`var a = 2;`的处理

1. 当看到`var a = 2;`时,我们认为这是一个生命,但是编译器却认为这里有两个完全不同的声明,一个由编译器在编译时处理,另一个则由引擎在运行时处理

2. 遇到`var a`,编译器会询问作用域是否已经有一个该名称的变量存在同一个作用域的集合中,如果是,则忽略该生命继续编译.否则他就会要求作用域在当前集合中声明一个新的变量,并命名为a.

3. 接下来编译器会为引擎生成运行时所需要的代码,这些代码用来处理`a=2`这个赋值操作.引擎运行时会首先询问作用域,当前集合中是否存在a变量,是的话就赋值给他,不是的话继续查找该变量.如果一直找不到,就抛异常.

### 为了进一步理解,我们需要多介绍一点编译器的术语(这章最恶心的地方来了)

编译器在编译的第二步中生成了代码,引擎执行它时,会通过查找a来判断它是否已被声明过.但是引擎执行怎样的查找,会影响最终的查找结果.  
在上面的例子中,引擎会为变量a进行LHS查询.(另外一种查找的类型叫做RHS).  
换句话说,当变量出现在赋值操作的左侧时进行LHS查询,出现在右侧时进行RHS查询.
讲的更准确一点,RHS查询与简单的查找某个变量的值别无二致而LHS查询是试图找到变量的容器本身.  
**可以理解RHS为"得到某某值"的行为**




