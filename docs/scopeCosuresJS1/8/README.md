# 作用域闭包

>**js的精髓**  
闭包是挺难的,我本人也是写了不少代码后才慢慢懂的什么是闭包,才明白原理是什么.

## 闭包是什么样子的

>这段一半是我写的,一半是书中的内容.

如果你百度搜索什么是闭包,99%的示例都是函数里面有变量,然后return一个子函数,子函数里引用了父函数的变量.然后你执行了父函数得到了子函数.再次执行子函数却神奇的发现能使用不是他作用域内的变量,也就是父函数内部的变量,并且是有状态的.

的确很神奇,这也是js闭包的经典运用,但是这不是闭包全部的样子.写个书上的代码(不包含状态的部分示例).

```js
function foo(){
    var a = 2;
    function bar(){
        console.log(a); 
    }
    return bar;
}
var baz = foo();
baz();  // 打印2
```

在 `foo` 函数被执行过后,理论上`foo`的整个内部作用域都会被js引擎的垃圾回收器用来释放不再使用的内存空间.

而闭包的神奇之处正是在于可以阻止这种事的发生.事实上,内部作用域依然存在,因此没有被回收,就是因为`bar()`本身在使用.

拜`bar()`所声明的位置所赐,他拥有覆盖`foo()`内部作用域的闭包,使得该作用域能够一直存活,以供`bar()`在之后任何时间进行引用.

`bar`依然有对该作用域的引用,而这个就叫做比 **闭包** .

```js
function foo(){
    var a = 2;
    function baz(){
        console.log(a);
        
    }
    bar(baz)
}
function bar(fn){
    fn()
}
foo()
```
这也是闭包的使用.

其实如果细心一想闭包的特性,其实所有的异步函数的回调方法不都是个闭包吗?

## 循环与闭包

```js
for(var i=1;i<=5;i++){
    setTimeout(function timer(){
        console.log(i);
    },i*1000)
}
```
就算是js的初学者也知道这道题应该不会是简单的输出123456,事实上也的确不是,程序会每隔一秒就会打印6,一共出现5次.

为什么呢?是因为这五个因为循环出来的域对i的引用都是同一个父级的域,所以他们其实拿到的是同一个i.问题发现了就知道怎么解决了,给每个定时器创建一个自己的域就ok了.

```js
for(var i=1;i<=5;i++){
    (function(j) {
        setTimeout(function timer(){
            console.log(j);
        },j*1000)
    })(i)
}
```





