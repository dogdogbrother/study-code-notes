# 异步:现在和将来

## 事件循环
尽管你显然能够编写异步 JavaScript 代码，但直到最近（ES6），JavaScript 才真正内建有直接的异步概念。

这种说法让人感觉到惊奇,但JavaScript 引擎本身所做的只不过是在需要的时候，在给定的任意时刻执行程序中的**单个代码块**.

js中对异步或是说多线程(这么说其实并不准确,异步和多线程并不是一个东西)都提供了一种机制来处理程序中多个块的执行，且执行每块时调用 JavaScript 引擎，这种机制被称为**事件循环**。

打个比方说,就是js有一个永远在对一个`eventLoop`数组执行的 `while` 循环,当我们发送一个AJAX请求时,服务器会监听返回响应,如果有响应的话就把当初写的那个回调函数插入到`eventLoop`数组尾部,当执行结束后就把这个回调函数删除掉.

一定要清楚，`setTimeout(..)` 并没有把你的回调函数挂在事件循环队列中。它所做的是设定一个定时器。当定时器到时后，环境会把你的回调函数放在事件循环中，这样，在未来某个时刻的 `tick` 会摘下并执行这个回调。

如果这时候事件循环中已经有 20 个项目了会怎样呢？你的回调就会等待。它得排在其他项目后面——通常没有抢占式的方式支持直接将其排到队首。这也解释了为什么
`setTimeout(..)` 定时器的精度可能不高。

## 任务

在 ES6 中，有一个新的概念建立在事件循环队列之上，叫作任务队列。这个概念给大家带来的最大影响可能是 `Promise` 的异步特性.

Promise的API机制还没有公开,书中的概念也是一个理解的描述.


