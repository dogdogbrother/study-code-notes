# 关于this的2个误解

>**this应该是目前端中出现最多的关键字了**  
先讲2个误解,最后总结this到底是啥东西.

## this指向自身
人们很容易把 this 理解成指向函数自身，这个推断从英语的语法角度来说是说得通的(笔者曾经也是这么以为的),但事实上却是不对的.

举个例子,我们想要记录下函数 foo 被调用的次数,思考一下下面的代码:

```js
function foo(num) { 
  console.log( "foo: " + num ); // 记录 foo 被调用的次数
  this.count++; 
}
foo.count = 0;
// 这里的代码意图很明显,因为函数也是对象,我们给foo加了一个属性count
// 如果this代表的是函数自身的话,那么foo.count就等于this.count

var i;

for (i=0; i<10; i++) {
  if (i > 5) { foo( i ); } 
}
//我们执行了五次foo函数,foo.count应该也等于5才是.

console.log( foo.count );

//然后事实上 打印出来的却是 0
```

#### 这里有一个疑问 “如果我增加的 count 属性和预期的不一样，那我增加的 this.count 是哪个 count ?”  
我们在前面的作用域章节里面有涉及到,如果当RHS查询不到对应的变量的时候,就会在全局创建一个变量`count`变量,值为NaN.

#### 如果我们想要实现记录`foo.count`,应该怎么做呢.
1. 第一种方法比较简单,就是让`count`脱离和`foo`的关联,单独是一个变量.这是比较简单的做法,利用了词法作用域.因为代码比较简单我就不贴了.
2. 第二种方法是真正的自己调用自己,也就是用`foo.count`代替`this.count`,我们上面也说了,代码失败的原因就是this不代表自己,用foo标识符就没问题.
3. 最后的方法是强制`this`执行`foo`函数对象.函数和上面的代码是一样的,不同的是在调用`foo`函数的时候使用call方法来改变this的指向.
```js
for (i=0; i<10; i++) {
  if (i > 5) {
    foo.call( foo, i ); 
  } 
}

console.log( foo.count ); // 4,没问题,正确
```

## this指向的是它的作用域

这个问题有点复杂，因为在某种情况下它好像是正确的,但是在其他情况下它却明显是错误的。

需要明确的是，`this` 在任何情况下都不指向函数的词法作用域。

在 `JavaScript` 内部，作用域确实和对象类似,可见的标识符都是它的属性。但是作用域“对象”无法通过 `JavaScript` 代码访问，它存在于 `JavaScript` 引擎内部。

## 小结,this到底是什么

`this`是在**运行时进行绑定**的,并不是在编写时绑定,它的上下文取决于函数调用时的各种条件。`this`的绑定和函数声明的位置没有任何关系,只取决于函数的调用方式。

当一个函数被调用时,会创建一个活动记录(有时候也称为执行上下文)。这个记录会包含函数在哪里被调用(调用栈)、函数的调用方法、传入的参数等信息。`this`就是记录的其中一个属性，会在函数执行的过程中用到。  

**`this`实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。**






